
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Rspec Practices - Jumpstart Lab Curriculum</title>
  <meta name="author" content="Jumpstart Lab">

  
  <meta name="description" content="        Rspec Practices          Getting going with RSpec is one thing, but let&#8217;s look at some techniques that can make your tests easier to ...">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://yoursite.com/internal_testing/rspec_practices.html">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection, print" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="http://s3.amazonaws.com/ender-js/jeesh.min.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Jumpstart Lab Curriculum" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

</head>

<body  >
  <header role="banner"><hgroup>
  <h1><a href="/">Jumpstart Lab Curriculum</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:yoursite.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
<ul class="main-navigation">
  <li><a href="/">Curriculum Index</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article role="article">
  
  <header>
    <h1 class="entry-title">Rspec Practices</h1>
    
  </header>
  
  <p>Getting going with RSpec is one thing, but let&#8217;s look at some techniques that can make your tests easier to write, more expressive to read, and easier to maintain.</p>

<h2>Setup and Teardown</h2>

<p>While writing examples which exercise your classes you will likely come across classes and states that are similar between multiple examples. For example:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
10<br>
11<br>
12<br>
13<br>
14<br>
15<br>
16<br>
17<br>
18<br>
describe Client do<br>
<br>
  it &quot;should respond to connect&quot; do<br>
    client = Client.new<br>
    client.should respond_to(:connect)<br>
  end<br>
<br>
  it &quot;should respond to disconnect&quot; do<br>
    client = Client.new<br>
    client.should respond_to(:disconnect)<br>
  end<br>
<br>
  it &quot;should respond to server_name&quot; do<br>
    client = Client.new<br>
    client.should respond_to(:server_name)<br>
  end<br>
<br>
end<br>
</p>

<p>In the above example we generate an new instance of <code>Client</code> before we make the assertion that it is responds to the particular methods. There are some drawbacks from this implementation:</p>

<ul>
<li>This is wasteful as we are repeating ourself several times within the tests.</li>
<li>Maintaining the tests is tedious; for example, returning later to make a change to the initialize method to take a parameter would require a lot of work.</li>
<li>The initialization somewhat obfuscates what is actually being tested.</li>
</ul>

<h3><code>before</code> and <code>after</code></h3>

<p>RSpec, like other test frameworks, provides helper methods for test setup and test tear down for individual examples and groups of examples. These helper methods are named <code>before</code> and <code>after</code>. Both of them accept an <code>:each</code> parameter to run one before each example, or <code>:all</code> to run once before all the examples:</p>

<ul>
<li><code>before :all</code></li>
<li><code>before :each</code></li>
<li><code>after :each</code></li>
<li><code>after :all</code></li>
</ul>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
10<br>
11<br>
12<br>
13<br>
14<br>
15<br>
16<br>
17<br>
18<br>
19<br>
describe Client do<br>
<br>
  before :each do<br>
    @client = Client.new<br>
  end<br>
<br>
  it &quot;should respond to connect&quot; do<br>
    @client.should respond_to(:connect)<br>
  end<br>
<br>
  it &quot;should respond to disconnect&quot; do<br>
    @client.should respond_to(:disconnect)<br>
  end<br>
<br>
  it &quot;should respond to server_address&quot; do<br>
    @client.should respond_to(:server_address)<br>
  end<br>
<br>
end<br>
</p>

<p>Here <code>before :each</code> execute the code contained within the block <code>do...end</code> before the execution of each of the examples.</p>

<p>In this trivial example we could have used before :all and set up our @client object once. It is important to know that changes made within a before :all block will not be rolled back after tests.<br>
</p>

<p>You can define a <code>before</code> and <code>after</code> within each <code>describe</code> or <code>context</code> block, allowing you to easily add setup and creation as necessary.</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
10<br>
11<br>
12<br>
13<br>
14<br>
15<br>
16<br>
17<br>
18<br>
19<br>
20<br>
21<br>
22<br>
23<br>
24<br>
25<br>
26<br>
27<br>
28<br>
29<br>
30<br>
31<br>
32<br>
33<br>
34<br>
35<br>
36<br>
37<br>
38<br>
39<br>
40<br>
41<br>
42<br>
43<br>
describe &quot;before/after example&quot; do<br>
<br>
  before :all do<br>
    puts &quot;before all&quot;<br>
  end<br>
<br>
  before :each do<br>
    puts &quot;before each&quot;<br>
  end<br>
<br>
  context &quot;when we are in a context&quot; do<br>
<br>
    before :all do<br>
      puts &quot; - before all&quot;<br>
    end<br>
<br>
    before :each do<br>
      puts &quot; - before each&quot;<br>
    end<br>
<br>
    it &quot;should&quot; do<br>
      true.should be_true<br>
    end<br>
<br>
    after :each do<br>
      puts &quot; - after each&quot;<br>
    end<br>
<br>
    after :all do<br>
      puts &quot; - after all&quot;<br>
    end<br>
<br>
  end<br>
<br>
  after :each do<br>
    puts &quot;after each&quot;<br>
  end<br>
<br>
  after :all do<br>
    puts &quot;after all&quot;<br>
  end<br>
<br>
end<br>
</p>

<p>Execution yields the following output:</p>

<pre><code>before/after example
before all
  when we are in a context
 - before all
before each
 - before each
 - after each
after each
    should
 - after all
after all
</code></pre>

<p>Notice that both <code>before :all</code> helper methods executed prior each of the <code>before :each</code> helper methods. This is reverse for our <code>after</code> helper methods.</p>

<h2>It is still Ruby</h2>

<p>RSpec may appear as if is a all together a different language that is allowing you to embed Ruby within it to exercise your code, but it is not. It is just Ruby!</p>

<p>We could refactor our previous <code>Client</code> examples even further:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
10<br>
11<br>
describe Client do<br>
  before :each do<br>
    @client = Client.new<br>
  end<br>
<br>
  [ :connect, :disconnect, :server_address ].each do |method|<br>
    it &quot;should respond #{method}&quot; do<br>
      @client.should respond_to(:connect)<br>
    end<br>
  end<br>
end<br>
</p>

<p>Creating an array of our three methods <code>:connect</code>, <code>:disconnect</code>, and <code>:server_address</code> and iterating over that array allow us to save the duplication of entries.</p>

<h2><code>describe</code></h2>

<p>The method <code>describe</code> helps us to group a set of related examples.</p>

<h3>Instance Methods</h3>

<p>Imagine we&#8217;re trying to test this <code>initialize</code> method:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
class Client<br>
  def initialize<br>
    # &#8230; initialization code &#8230;<br>
  end<br>
end<br>
</p>

<p>Then, when we write examples about that method, we wrap them in a <code>describe</code> block with the name of the method prefixed with a <code>#</code> to indicate it is an instance method:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
describe Client do<br>
  describe &#39;#initialize&#39; do<br>
    it &#39;should respond with default values&#39; do<br>
      # &#8230; arrange, act, assert &#8230;<br>
    end<br>
  end<br>
end<br>
</p>

<h3>Class Methods</h3>

<p>Similarly, when testing class methods we&#8217;ll prefix the name with a period (<code>.</code>):</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
class Client<br>
  def self.generate<br>
    # &#8230; generation code &#8230;<br>
  end<br>
end<br>
</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
describe Client do<br>
  describe &#39;.generate&#39; do<br>
    it &#39;should return a valid Client instance&#39; do<br>
      # &#8230; arrange, act, assert &#8230;<br>
    end<br>
  end<br>
end<br>
</p>

<h2>Explicit Subject</h2>

<p>Let&#8217;s return to our previous example of the <code>Client</code> examples:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
describe Client do<br>
  before(:all) do<br>
    @client = Client.new<br>
  end<br>
<br>
  it { @client.should respond_to :connect }<br>
  it { @client.should respond_to :disconnect }<br>
  it { @client.should respond_to :server_name }<br>
end<br>
</p>

<p>We saved ourselves the hassle of having to generate a <code>Client</code> each execution with the <code>before(:all)</code>, but we still have the instance variable <code>@client</code> throughout our examples. </p>

<p>RSpec has the convention that when you call <code>should</code> without an <em>explicit receiver</em> it is assumed that you mean to make an assertion against the <code>subject</code> under test. This is called <a href="https://www.relishapp.com/rspec/rspec-core/docs/subject/implicit-receiver">Implicit Receiver</a>.</p>

<p>Let us define a <code>subject</code> and allow for it to be the implicit receiver. </p>

<p>Revisiting the previous example:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
10<br>
11<br>
describe Client do<br>
  before(:all) do<br>
    @client = Client.new<br>
  end<br>
<br>
  subject { @client }<br>
<br>
  it { should respond_to :connect   }<br>
  it { should respond_to :disconnect }<br>
  it { should respond_to :server_name }<br>
end<br>
</p>

<p>We were able to remove the use of the member variable <code>@client</code> from all the test examples and place it within the <code>subject</code> helper. The result of which will be used implicitly everywhere we previously had used it. Saving us a lot of typing.</p>

<p>However, RSpec goes even further to make us faster and more effective test driven developers.</p>

<h3><a href="https://www.relishapp.com/rspec/rspec-core/docs/subject/implicit-subject">Implicit Subject</a></h3>

<p>Using the class name <code>Client</code> in the outermost <code>describe</code> grants us the benefit of having an instance of object under test automatically available through the <code>subject</code> helper method.</p>

<p>Again returning to our previous example, we can remove our explicit declaration of the subject and rely on the implicit subject:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
describe Client do<br>
  it { should respond_to :connect   }<br>
  it { should respond_to :disconnect }<br>
  it { should respond_to :server_name }<br>
end<br>
</p>

<p>Or even more succinctly:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
describe Client do<br>
  [ :connect, :disconnect, :server_name ].each do |method|<br>
    it { method respond_to attribute }<br>
  end<br>
end<br>
</p>

<h3><code>its</code></h3>

<p>After asserting that a class responds to particular methods we may be interested in making assertions about default values. A great shorthand is the <code>its</code> keyword which provides a shortcut for the implicit subject&#8217;s attributes.</p>

<p>If our example class had default values we could use the following to quickly make assertions:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
describe Client do<br>
  context &quot;created with defaults&quot; do<br>
    its(:server_name) { should eq(&quot;<a href="http://defaultserver.com">http://defaultserver.com</a>&quot;) }<br>
  end<br>
end<br>
</p>

<h2><code>let</code></h2>

<p>RSpec&#8217;s <code>let</code> defines a helper method. The value returned by the <code>let</code> block is cached for the execution of the single example.</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
10<br>
describe Square do<br>
  let (:expected_area) { 10 * 10 }<br>
<br>
  it &#39;should have the expected area&#39; do<br>
    subject.width = 10<br>
    subject.area.should eq(expected_area)<br>
    subject.height = 10<br>
    subject.area.should eq(expected_area)<br>
  end<br>
end<br>
</p>

<p>During the test of our <code>Square</code> class we made an assertion that the area of the square class is equal to the <code>expected_area</code>. As a performance benefit this was only calculated once. This may appear trivial in the previous example, however, this proves useful if the data underneath you may change.</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
describe Customer do<br>
<br>
  let (:customer) { Customer.first }<br>
<br>
  it &#39;should have a full name that is composed of their first name and last name&#39; do<br>
      customer.full_name.should eq(&quot;#{customer.first_name} #{customer.last_name}&quot;)<br>
    end<br>
  end<br>
end<br>
</p>

<p>Here we see the benefit of the value being memoized, or cached, during the same execution of the example. Our example does not have to return to the database to find the first customer multiple times. Second, we are protected if our database were to change during the test because of another concurrently executing test.</p>

<p>Alongside of <code>let</code> there is also <code>let!</code>. In both of the above examples the value was loaded and cached on first use (lazy initialization). With <code>let!</code> the value is <em>immediately</em> cached at the beginning of the execution of the example.</p>

<h2>Shared Examples</h2>

<p>Often you will find that classes share similar functionality. Take for example the two models outlined:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
class Article<br>
  # &#8230; other code unique to an article &#8230;<br>
  attr_reader :author, :publish_date, :featured<br>
end<br>
<br>
class Video<br>
  # &#8230; other code unique to a video &#8230;<br>
  attr_reader :author, :publish_date, :featured<br>
end<br>
</p>

<p>Within your test suite you likely have examples for your <code>Article</code> like this:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
describe Article do<br>
  [ :author, :publish_date, :featured ].each do |attribute|<br>
    it { should respond_to attribute }<br>
  end<br>
end<br>
</p>

<p>It is tempting to copy/paste the code to the <code>Video</code> examples. The RSpec framework provides functionality to assist with sharing characteristics across different models through <code>shared_examples</code></p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
10<br>
11<br>
12<br>
13<br>
shared_examples &quot;a published document&quot; do<br>
  [ :author, :publish_date, :featured ].each do |attribute|<br>
    it { should respond_to attribute }<br>
  end<br>
end<br>
<br>
describe Article do<br>
  it_behaves_like &quot;a published document&quot;<br>
end<br>
<br>
describe Video do<br>
  it_behaves_like &quot;a published document&quot;<br>
end<br>
</p>

<p>To make the <code>shared_examples</code> available across multiple spec files, you&#8217;d need to define or load it in the common <code>spec_helper.rb</code>.</p>

<h2>Special Matchers</h2>

<h3>to <code>should be</code> or <code>should_not be_nil</code> that is the question&#8230;</h3>

<p>RSpec has a number of great matchers available to help make assertions more clear. You can use comparisons with <code>==</code> and write:</p>

<p>1<br>
2<br>
nil_object.should == nil<br>
object.should != nil<br>
</p>

<p>It is much more elegant to use the custom matchers provided by RSpec:</p>

<p>1<br>
2<br>
nil_object.should be_nil<br>
object.should be<br>
</p>

<p>Try to stating your assertions in the positive, preferring that an <code>object.should be</code> over an object <code>object.should_not be_nil</code>.</p>

<h3>Using lambdas</h3>

<p>RSpec aliases Ruby&#8217;s <code>lambda</code> to <code>expect</code>, allowing this:</p>

<p>1<br>
lambda { Object.new.unknown_method }.should raise_error<br>
</p>

<p>To be written:</p>

<p>1<br>
expect { Object.new.unknown_method }.should raise_error<br>
</p>

<h2>Command Line Options</h2>

<p>RSpec has many options that can be controlled from the command line.</p>

<h3>Example execution by line</h3>

<p>You can execute a specific example based on the line number:</p>

<pre><code>rspec spec/model_spec.rb:9
</code></pre>

<p>This type of isolation is extremely useful to determine if setup, teardown, or other examples are causing conflicts with the given example you are executing.</p>

<h3>Output Formats</h3>

<p>RSpec supports multiple different output formats:</p>

<ul>
<li>progress is the default and the most minimal simply drawing dots for passing examples and Fs for failed examples.</li>
<li>documentation, <code>rspec -f d</code>, displays the text defined in your groups and examples giving you a richer, more human-readable output</li>
<li>html, <code>rspec -f h</code>, displays the output to HTML. This format is usually accompanied with the results being sent to a file with the <code>-o</code> command like this:
<code>
rspec -f h spec/model_spec.rb -o model_spec.html`.
</code></li>
</ul>

<h3>Guard</h3>

<p>Guard is a system for execution actions when files in your application change. One common use is to run your test when a file being tested changes.</p>

<h4>Setup</h4>

<p>Add <code>guard</code> and <code>guard-rspec</code> to your Gemfile:</p>

<p>1<br>
2<br>
3<br>
4<br>
group :test, :development do<br>
  gem &#39;guard&#39;<br>
  gem &#39;guard-rspec&#39;<br>
end<br>
</p>

<p>Run <code>bundle</code>, then initialize guard and add the default RSpec file monitoring:</p>

<pre><code>$ bundle install
$ guard init
$ guard rspec
</code></pre>

<p>Editing the RSpec entry in the Guardfile to add color and documentation format:</p>

<p>1<br>
2<br>
3<br>
4<br>
# &#8230; within your Guardfile<br>
guard &#39;rspec&#39;, :cli =&gt; &quot;&#8211;color &#8211;format documentation&quot; do<br>
  # &#8230;<br>
end<br>
</p>

<p>Execution:</p>

<pre><code>$ guard
</code></pre>

<h2>Database Cleaner</h2>

<p>It&#8217;s surprisingly easy to leave data hanging around your test database. The most common scenario is when using <code>before :all</code> blocks which can&#8217;t be automatically rolled back when the tests are complete.</p>

<p>Having this data lingering around can lead to unexpected results in your examples.</p>

<p>The Database Cleaner gem takes care of maintaining your database for you.</p>

<h3>Gem Setup</h3>

<p>Add <code>database_cleaner</code> to your <code>Gemfile</code> and run <code>bundle</code>.</p>

<h3>SpecHelper</h3>

<p>Then, in your <code>spec_helper.rb</code>, add this config:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
10<br>
11<br>
12<br>
13<br>
14<br>
15<br>
Spec::Runner.configure do |config|<br>
<br>
  config.before(:suite) do<br>
    DatabaseCleaner.strategy = :transaction<br>
    DatabaseCleaner.clean_with(:truncation)<br>
  end<br>
<br>
  config.before(:each) do<br>
    DatabaseCleaner.start<br>
  end<br>
<br>
  config.after(:each) do<br>
    DatabaseCleaner.clean<br>
  end<br>
end<br>
</p>

<p>Now your database will be pristine between test runs!</p>

<h2>Exercises</h2>

<p>[TODO: JSBlogger Setup]</p>

<ol>
<li>Write two examples for the <code>Article</code> class that use <code>before :each</code> to share common setup code.</li>
<li>Refactor those two examples to use the <em>implicit receiver</em>.</li>
<li>Experimenting with Database Cleaner:

<ul>
<li>Write a <code>before :all</code> block that creates five articles in the database</li>
<li>Run the examples</li>
<li>Start a console attached to the test database with <code>rails console test</code></li>
<li>Verify that the records are still sitting there in the database then exit the console</li>
<li>Clear the database with <code>rake db:test:prepare</code></li>
<li>Setup Database Cleaner as described above</li>
<li>Run the examples</li>
<li>Re-open the console and verify that no records remain in the database</li>
</ul></li>
<li>Use <code>expect</code> to check that a method does not raise an exception given invalid input.</li>
<li>Experiment with running RSpec with each format:

<ul>
<li>the default</li>
<li>documentation using <code>rspec -f d</code></li>
<li>html output to a file like:
<code>
rspec -f h spec/model_spec.rb -o model_spec.html`.
</code><br></li>
</ul></li>
</ol>

<h2>References</h2>

<ul>
<li>Explicit Subject (<code>it</code>): <a href="https://www.relishapp.com/rspec/rspec-core/docs/subject/explicit-subject">https://www.relishapp.com/rspec/rspec-core/docs/subject/explicit-subject</a></li>
<li>Implicit Receiver : <a href="https://www.relishapp.com/rspec/rspec-core/docs/subject/implicit-receiver">https://www.relishapp.com/rspec/rspec-core/docs/subject/implicit-receiver</a></li>
<li>Attributes of Subject (<code>its</code>): <a href="https://www.relishapp.com/rspec/rspec-core/docs/subject/attribute-of-subject">https://www.relishapp.com/rspec/rspec-core/docs/subject/attribute-of-subject</a></li>
<li><code>let</code>: <a href="https://www.relishapp.com/rspec/rspec-core/docs/helper-methods/let-and-let">https://www.relishapp.com/rspec/rspec-core/docs/helper-methods/let-and-let</a></li>
<li>Shared Examples: <a href="https://www.relishapp.com/rspec/rspec-core/docs/example-groups/shared-examples">https://www.relishapp.com/rspec/rspec-core/docs/example-groups/shared-examples</a></li>
<li>Special Matchers: <a href="https://www.relishapp.com/rspec/rspec-expectations">https://www.relishapp.com/rspec/rspec-expectations</a></li>
<li>Output Formats: <a href="https://www.relishapp.com/rspec/rspec-core/docs/command-line/format-option">https://www.relishapp.com/rspec/rspec-core/docs/command-line/format-option</a></li>
<li>Database Cleaner: <a href="https://github.com/bmabey/database_cleaner">https://github.com/bmabey/database_cleaner</a></li>
</ul>

  
    <footer>
      
      
        <div class="sharing">
  
  
</div>

      
    </footer>
  
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
  </ul>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2011 - Jumpstart Lab -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  


  

  

  

</body>
</html>
