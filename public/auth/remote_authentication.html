
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Remote Authentication - Jumpstart Lab Curriculum</title>
  <meta name="author" content="Jumpstart Lab">

  
  <meta name="description" content="        Remote Authentication          There have been about a dozen popular methods for authenticating Rails applications over the past five years...">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://yoursite.com/auth/remote_authentication.html">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="http://s3.amazonaws.com/ender-js/jeesh.min.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Jumpstart Lab Curriculum" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

</head>

<body   class="no-sidebar" >
  <div id="main">
    <div id="content">
      <div>
<article role="article">
  
  <header>
    <h1 class="entry-title">Remote Authentication</h1>
    
  </header>
  
  <p>There have been about a dozen popular methods for authenticating Rails applications over the past five years. </p>

<p>As we learn more about constructing web applications there is a greater emphasis on decoupling components. It makes a lot of sense to depend on an external service for our authentication, then that service can serve this application along with many others.</p>

<p>It&#8217;s easiest to understand how OmniAuth works by implementing it. It&#8217;s recommended you checkout the JSBlogger sample application and follow along.</p>

<p>[TODO: JSBlogger Setup]<br>
</p>

<h2>Why OmniAuth?</h2>

<p>The best application of this concept is the <a href="https://github.com/intridea/omniauth">OmniAuth</a>. </p>

<p>It&#8217;s popular because it allows you to use multiple third-party services to authenticate, but it is really a pattern for component-based authentication. You could let your users login with their Twitter account, but you could also build your own centralized OmniAuth provider that authenticates all your company&#8217;s apps. Maybe you can use the existing LDAP provider to hook into ActiveDirectory or OpenLDAP, or make use of the Google Apps interface.</p>

<p>Better yet, OmniAuth can handle multiple concurrent strategies, so you can offer users multiple ways to authenticate. Your app is just built against the OmniAuth interface, those external components can come and go.</p>

<h2>Getting Started with OmniAuth</h2>

<p>The first step is to add the dependency to your <code>Gemfile</code>:</p>

<p>1<br>
  gem &quot;omniauth&quot;, &quot;~&gt; 0.3.0&quot;<br>
</p>

<p>Then run <code>bundle</code> from your terminal.</p>

<h3>Rack Middleware</h3>

<p>OmniAuth runs as a &quot;Rack Middleware&quot; which means it&#8217;s not really a part of our app, it&#8217;s a thin layer between our app and the client. </p>

<h4>Create the Initializer</h4>

<p>To instantiate and control the middleware, we need an initializer. You&#8217;d  create <code>/config/initializers/omniauth.rb</code> and add the following:</p>

<p>1<br>
2<br>
3<br>
Rails.application.config.middleware.use OmniAuth::Builder do<br>
  provider :twitter, &quot;EZYxQSqP0j35QWqoV0kUg&quot;, &quot;IToKT8jdWZEhEH60wFL94HGf4uoGE1SqFUrZUR34M4&quot;<br>
end<br>
</p>

<p>What is all that?  Twitter, like many API-providing services, wants to track who&#8217;s using it. They accomplish this by distributing API accounts. </p>

<p>Specifically, they use the OAuth protocol which requires a <em>consumer key</em> and a <em>consumer secret.</em>  If you want to build an application using the Twitter API you&#8217;ll need to <a href="https://dev.twitter.com/apps">register and get your own credentials</a></p>

<h3>Accessing the Remote Service</h3>

<p>You need to restart your server so the initializer is run and the middleware loaded. The default URL pattern is:</p>

<p>1<br>
http://your.com/auth/provider<br>
</p>

<p>Where <code>provider</code> could be <code>twitter</code>, <code>facebook</code>, or any other registered OmniAuth provider. We&#8217;ll experiment using Twitter.</p>

<p>In your browser go to <a href="http://127.0.0.1:8080/auth/twitter">http://127.0.0.1:8080/auth/twitter</a> and, after a few seconds, you should see a Twitter login page. </p>

<p>Login to Twitter using any account, then you should see a Routing Error from your application. If you’ve got that, then things are on the right track.</p>

<p>If you get to this point and encounter a 401 Unauthorized message there is more work to do. You’re probably using your own API key and secret. You need to go into the settings on Twitter for your application, and add <a href="http://127.0.0.1">http://127.0.0.1</a> as a registered callback domain. Also add <a href="http://0.0.0.0">http://0.0.0.0</a> and http://localhost while you&#8217;re in there. </p>

<p>Now give it a try and you should get the Routing Error.<br>
</p>

<h3>Handling the Callback</h3>

<p>The authentication pattern starts with your app redirecting to the third party authenticator, the third party processes the authentication, then it sends the user back to your application at a <em>callback URL</em>. OmniAuth defaults to listening at <code>/auth/twitter/callback</code>. </p>

<p>You&#8217;d handle that callback by adding a route in <code>/config/routes.rb</code>:</p>

<p>1<br>
match &#39;/auth/:provider/callback&#39;, :to =&gt; &#39;sessions#create&#39;<br>
 </p>

<p>Your router will attempt to call the <code>create</code> action of the <code>SessionsController</code> when the callback is triggered.</p>

<h3>Creating a Sessions Controller</h3>

<p>You can generate a controller at the command line and add a create method like this:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
class SessionsController &lt; ApplicationController<br>
  def create<br>
    render :text =&gt; debug request.env[&quot;omniauth.auth&quot;]<br>
  end<br>
end<br>
</p>

<p>Calling <code>render :text</code> is a good debugging technique to display plain text as the response. Here you&#8217;d see the response body data stored under the <code>omniauth.auth</code> key.</p>

<h3>Creating a User Model</h3>

<p>Even though we&#8217;re using an external service for authentication, we&#8217;ll still need to keep track of user objects within our system. Let&#8217;s create a model that will be responsible for that data. </p>

<p>As you saw, Twitter gives us a ton of data about the user. What should we store in our database?  The minimum expectations for an OmniAuth provider are three things:</p>

<ul>
<li><code>provider</code> - A string name uniquely identifying the provider service</li>
<li><code>uid</code> - An identifying string uniquely identifying the user within that provider</li>
<li><code>name</code> - Some kind of human-meaningful name for the user</li>
</ul>

<p>Let&#8217;s start with just those three in our model. From your terminal:</p>

<p>1<br>
rails generate model User provider:string uid:string name:string<br>
</p>

<p>Then update the database with <code>rake db:migrate</code>.</p>

<h3>Creating Actual Users</h3>

<p>How you create users might vary depending on the application. For our demonstration, we&#8217;ll allow anyone to create an account automatically just by logging in with the third party service.</p>

<p>Hop back to the <code>SessionsController</code>. The controller should have as little domain logic as possible, so we&#8217;ll proxy the User lookup/creation from the controller down to the model like this:</p>

<p>1<br>
2<br>
3<br>
  def create<br>
    @user = User.find_or_create_by_auth(request.env[&quot;omniauth.auth&quot;])<br>
  end<br>
</p>

<p>Now the <code>User</code> model is responsible for figuring out what to do with that big hash of data from Twitter. Open the model file and add this method:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
  def self.find_or_create_by_auth(auth_data)<br>
    user = self.find_or_create_by_provider_and_uid(auth_data[&quot;provider&quot;], auth_data[&quot;uid&quot;])<br>
    if user.name != auth_data[&quot;user_info&quot;][&quot;name&quot;]<br>
      user.name = auth_data[&quot;user_info&quot;][&quot;name&quot;]<br>
      user.save<br>
    end<br>
    return user<br>
  end<br>
</p>

<p>To walk through that step by step&#8230;</p>

<ul>
<li>Look in the users table for a record with this <code>provider</code> and <code>uid</code> combination. If it&#8217;s found, you&#8217;ll get it back. If it&#8217;s not found, a new record will be created and returned</li>
<li>Compare the user&#8217;s <code>name</code> and the <code>name</code> in the auth data. If they&#8217;re different, either this is a new user and we want to store the name or they&#8217;ve changed their name on the external service and it should be updated here. Then save it.</li>
<li>Either way, return the <code>user</code></li>
</ul>

<p>Now, back to <code>SessionsController</code>, we need to save the logged in user&#8217;s id in the session. And let&#8217;s add a redirect action to send them to the <code>articles_path</code> after login:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
  def create<br>
    @user = User.find_or_create_by_auth(request.env[&quot;omniauth.auth&quot;])<br>
    session[:user_id] = @user.id<br>
    redirect_to articles_path, :notice =&gt; &quot;Logged in as #{@user.name}&quot;<br>
  end<br>
</p>

<p>Now visit <code>/auth/twitter</code> and you should eventually be redirected to the Articles listing.</p>

<h3>UI for Login/Logout</h3>

<p>That&#8217;s exciting, but now we need links for login/logout that don&#8217;t require manually manipulating URLs. Anything like login/logout that you want visible on every page goes in the layout.</p>

<p>Open <code>/app/views/layouts/application.html.erb</code> and you&#8217;ll see the framing for all our view templates. Let&#8217;s add in the following:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
  &lt;div id=&quot;account&quot;&gt;<br>
    &lt;% if current_user %&gt;<br>
      &lt;span&gt;Welcome, &lt;%= current_user.name %&gt;&lt;/span&gt;<br>
      &lt;%= link_to &quot;logout&quot;, logout_path, :id =&gt; &quot;login&quot; %&gt;<br>
    &lt;% else %&gt;<br>
      &lt;%= link_to &quot;login&quot;, login_path, :id =&gt; &quot;logout&quot; %&gt;<br>
    &lt;% end %&gt;<br>
  &lt;/div&gt;<br>
</p>

<p>If you refresh your browser that will crash for several reasons.</p>

<h3>Accessing the Current User</h3>

<p>It&#8217;s a convention that Rails authentication systems provide a <code>current_user</code> method to access the user. </p>

<p>Let&#8217;s create that in our <code>ApplicationController</code> with these steps:</p>

<ul>
<li><p>Underneath the <code>protect_from_forgery</code> line, add this: </p>

<pre lang="ruby"><code>helper_method :current_user
</code></pre></li>
<li><p>Just before the closing <code>end</code> of the class, add this:</p>

<pre lang="ruby"><code>  private
    def current_user
      @current_user ||= User.find(session[:user_id]) if session[:user_id]
    end  
</code></pre></li>
</ul>

<p>By defining the <code>current_user</code> method as private in <code>ApplicationController</code>, that method will be available to all our controllers because they inherit from <code>ApplicationController</code>. </p>

<p>In addition, the <code>helper_method</code> line makes the method available to all our views. Now we can access <code>current_user</code> from any controller and any view!</p>

<h4>Progress Check</h4>

<p>Refresh the page in your browser and you&#8217;ll move on to the next error:</p>

<p>1<br>
undefined local variable or method `login_path&#39;.<br>
</p>

<h3>Convenience Routes</h3>

<p>Just because we&#8217;re following the REST convention doesn&#8217;t mean we can&#8217;t also create our own named routes. The view snippet we wrote is attempting to link to <code>login_path</code> and <code>logout_path</code>, but our application doesn&#8217;t yet know about those routes.</p>

<p>Open <code>/config/routes.rb</code> and add two custom routes:</p>

<p>1<br>
2<br>
  match &quot;/login&quot; =&gt; redirect(&quot;/auth/twitter&quot;), :as =&gt; :login<br>
  match &quot;/logout&quot; =&gt; &quot;sessions#destroy&quot;, :as =&gt; :logout<br>
</p>

<p>The first line creates a path named <code>login</code> which redirects to the static address <code>/auth/twitter</code> which will be intercepted by the OmniAuth middleware. The second line creates a <code>logout</code> path which will call the <code>destroy</code> action of our <code>SessionsController</code>.</p>

<p>With those in place, refresh your browser and it should load without error.</p>

<h3>Implementing Logout</h3>

<p>Our login works great, but we can&#8217;t logout!  When you click the logout link it&#8217;s attempting to call the <code>destroy</code> action of <code>SessionsController</code>. Let&#8217;s implement that.</p>

<ul>
<li>Open <code>SessionsController</code></li>
<li>Add a <code>destroy</code> method</li>
<li><p>In the method, erase the session with:</p>

<pre lang="ruby"><code>session[:user_id] = nil
</code></pre></li>
<li><p>Redirect to the <code>root_path</code> with the notice <code>&quot;Goodbye!&quot;</code></p></li>
<li><p>Define a <code>root_path</code> in your router like this: </p>

<pre lang="ruby"><code>root :to =&gt; &quot;article#index&quot;
</code></pre></li>
</ul>

<h3>Wrapup</h3>

<p>At that point, your login/logout system should be working!</p>

<p>That&#8217;s just the beginning with OmniAuth. Now, you could choose to add other providers by adding API keys to the initializer and properly handling the different routes.</p>

<p>You might try out some of these:</p>

<ul>
<li>A Devise and OmniAuth powered Single-Sign-On implementation: <a href="https://github.com/joshsoftware/sso-devise-omniauth-provider">https://github.com/joshsoftware/sso-devise-omniauth-provider</a></li>
<li>RailsCast on combining Devise and OmniAuth: <a href="http://asciicasts.com/episodes/236-omniauth-part-2">http://asciicasts.com/episodes/236-omniauth-part-2</a></li>
</ul>

<h2>References</h2>

<ul>
<li>OmniAuth core API documentation: <a href="https://github.com/intridea/omniauth">https://github.com/intridea/omniauth</a></li>
<li>OmniAuth wiki: <a href="https://github.com/intridea/omniauth/wiki">https://github.com/intridea/omniauth/wiki</a></li>
</ul>

  
</article>

</div>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2011 - Jumpstart Lab -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
</body>
</html>
