
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Validations - Jumpstart Lab Curriculum</title>
  <meta name="author" content="Jumpstart Lab">

  
  <meta name="description" content="        Validations          Data integrity is an underrated part of proper application architecture. Many of the bugs in production systems are tr...">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://yoursite.com/models/validations.html">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="http://s3.amazonaws.com/ender-js/jeesh.min.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Jumpstart Lab Curriculum" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

</head>

<body   class="no-sidebar" >
  <div id="main">
    <div id="content">
      <div>
<article role="article">
  
  <header>
    <h1 class="entry-title">Validations</h1>
    
  </header>
  
  <p>Data integrity is an underrated part of proper application architecture. Many of the bugs in production systems are triggered by missing or malformed user data. If a user can possibly screw it up or screw with it, they will. Validations in the model can help!</p>

<h2>On Syntax</h2>

<p>Before we begin, let&#8217;s talk about syntax. There are two primary syntaxes for writing validations in Rails 3:</p>

<p>1<br>
2<br>
validates_presence_of :price<br>
validates :price, :presence =&gt; true<br>
</p>

<p>These have the exact same functionality. The first is the older style and the second a newer &quot;Rails 3 style&quot;. The Rails 3 style shines when we add in a second validation on the same field:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
# Rails 2 Style<br>
validates_presence_of :price<br>
validates_numericality_of :price<br>
<br>
# Rails 3 Style<br>
validates :price, :presence =&gt; true, :numericality =&gt; true<br>
</p>

<p>The newer syntax allows you to condense multiple validations into a single line of code.</p>

<p>In my opinion, the newer syntax is not good. Clean Ruby reads like English. To read the second set of examples aloud:</p>

<p>Rails 2 Style: &quot;validates presence of price, validates numericality of price&quot;</p>

<p>Rails 3: &quot;validates price presence true numericality true&quot;</p>

<p>The Rails 2 sentence isn&#8217;t poetry, but you can understand what it means. The Rails 3 syntax sounds like computer talk. Ruby is about developers not computers, and for that reason I recommend you not use the new syntax.</p>

<p>Aaron Patterson on the Rails core team confirms that there are no plans to deprecate the older syntax.<br>
</p>

<h2>Most Valuable Validations</h2>

<p>There are many validations available to you, check out the full API here: <a href="http://api.rubyonrails.org/classes/ActiveModel/Validations/HelperMethods.html">http://api.rubyonrails.org/classes/ActiveModel/Validations/HelperMethods.html</a></p>

<p>Let&#8217;s take a closer look at the most commonly used methods.</p>

<h3>Presence</h3>

<p><code>validates_presence_of</code></p>

<p>Declare that the field must have some value. Note that an empty string (<code>&quot;&quot;</code>) is <em>not</em> considered a value.</p>

<h4>Usage</h4>

<p>1<br>
validates_presence_of :title<br>
</p>

<p>Also, you can declare the validation on multiple fields at once:</p>

<p>1<br>
validates_presence_of :title, :price, :description<br>
</p>

<h3>Numericality</h3>

<p><code>validates_numericality_of</code></p>

<p>Check that the value in the field &quot;looks like&quot; a number. It might be a string, but does it look like a number? <code>&quot;123&quot;</code> does, <code>&quot;3.45&quot;</code> does, while <code>&quot;hello&quot;</code> does not. Neither does <code>&quot;a928&quot;</code>. I&#8217;ll tend to apply this to every field that is a number in the database (ex: <code>price</code>) and ones that look like a number but are stored as a string (ex: <code>zipcode</code>).</p>

<h4>Usage</h4>

<p>1<br>
validates_numericality_of :price<br>
</p>

<p>That basic usage will allow anything that&#8217;s &quot;number-like&quot; including integers or floats.</p>

<h4>Options</h4>

<p>We can add a few options to add criteria to our &quot;numbers&quot;:</p>

<ul>
<li><code>:only_integer</code> will only accept integers</li>
</ul>

<pre lang="ruby"><code>  validates_numericality_of :price, :only_integer =&gt; true
</code></pre>

<ul>
<li>Control the range of values with these options:

<ul>
<li><code>:greater_than</code></li>
<li><code>:greater_than_or_equal_to</code></li>
<li><code>:less_than</code></li>
<li><code>:less_than_or_equal_to</code><br>
For example:</li>
</ul></li>
</ul>

<pre lang="ruby"><code>  validates_numericality_of :price, :greater_than =&gt; 0
  validates_numericality_of :price, :less_than =&gt; 1000
  validates_numericality_of :price, :greater_than =&gt; 0, :less_than =&gt; 1000
</code></pre>

<h3>Length</h3>

<p><code>validates_length_of</code></p>

<p>Check the length of a string with <code>validates_length_of</code>.</p>

<h4>Usage &amp; Options</h4>

<p><code>validates_length_of</code> obviously needs to know what the length should be. Here are a few examples of the common specifiers:</p>

<p>1<br>
2<br>
3<br>
4<br>
validates_length_of :zipcode, :is =&gt; 5<br>
validates_length_of :title, :minimum =&gt; &quot;10&quot;<br>
validates_length_of :title, :maximum =&gt; &quot;1000&quot;<br>
validates_length_of :title, :in =&gt; (10..1000)<br>
</p>

<h3>Format</h3>

<p><code>validates_format_of</code></p>

<p>The <code>validates_format_of</code> method is the Swiss Army knife of validations. It attempts to match the input against a regular expression, so anything you can write in a regex you can check with this validator.</p>

<p>I always like to share Jamie Zawinski&#8217;s quote when talking about this topic: &quot;Some people, when confronted with a problem, think &#8216;I know, I&#8217;ll use regular expressions.&#8217; Now they have two problems.&quot;</p>

<p>But if you&#8217;re comfortable and capable with regular expressions, have at it!<br>
</p>

<h4>Usage</h4>

<p>The canonical example is email address format validation:</p>

<p>1<br>
validates_format_of :email, :with =&gt; /\A([^@\s]+)@((?:[-a-z0-9]+.)+[a-z]{2,})\Z/i<br>
</p>

<p>Or reject based on a regex using the <code>:without</code> option:</p>

<p>1<br>
validates_format_of :comment, :without =&gt; /(&lt;script&gt;|&lt;\/script&gt;)/<br>
</p>

<h3>Inclusion</h3>

<p><code>validates_inclusion_of</code></p>

<p>Check that a value is in a given set with <code>validates_inclusion_of</code>.</p>

<h4>Usage</h4>

<p>1<br>
validates_inclusion_of :birth_year, :in =&gt; (1880..2011)<br>
</p>

<p>The <code>:in</code> parameter will accept a Ruby range like this example or any other <code>Enumerable</code> object (like an <code>Array</code>).</p>

<h3>Custom Validations</h3>

<p>For custom validations, call the <code>validate</code> method with a symbol specifying the instance method to be called. When a record is saved, that method will be called.</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
validate :not_spammy<br>
<br>
def not_spammy<br>
  if self.description.downcase.include?(&quot;enhancement&quot;)<br>
    errors.add(:base, &quot;The description sounds spammy&quot;)<br>
  end<br>
end<br>
</p>

<p>Rails will not respect the return value of that method, it determines pass/fail based on whether any error messages were added to the object. To make the validation fail by call <code>errors.add(:base, message)</code>. If no errors are added, the validation passes.</p>

<h2>Validations in the User Interface</h2>

<p>Having expressed validations in the model, let&#8217;s see how to make use of them in the user interface.</p>

<h3>Understanding Errors</h3>

<p>As an example, assume we have this model:</p>

<p>1<br>
2<br>
3<br>
class Product &lt; ActiveRecord::Base<br>
  validates_presence_of :title<br>
end<br>
</p>

<h4>In the Console</h4>

<p>Trigger the validation:</p>

<p>1<br>
2<br>
3<br>
4<br>
ruby-1.9.2-p290 :001 &gt; p = Product.new<br>
 =&gt; #&lt;Product id: nil, title: nil, price: nil, description: nil, image_url: nil, created_at: nil, updated_at: nil, stock: 0&gt; <br>
ruby-1.9.2-p290 :002 &gt; p.valid?<br>
 =&gt; false <br>
</p>

<p>Calling the <code>valid?</code> method on an instance will run the validations and return <code>true</code> or <code>false</code>. From there, we can dig into the errors:</p>

<p>1<br>
2<br>
3<br>
4<br>
ruby-1.9.2-p290 :003 &gt; p.errors<br>
 =&gt; {:title=&gt;[&quot;can&#39;t be blank&quot;]} <br>
ruby-1.9.2-p290 :004 &gt; p.errors.full_messages<br>
 =&gt; [&quot;Title can&#39;t be blank&quot;] <br>
</p>

<p>The <code>.errors</code> method returns an <code>ActiveRecord::Errors</code> collection, which looks like a hash, with the attribute name as the key and the message(s) in an array. The convenience method <code>.full_messages</code> on that object returns an array of nicely formatted sentence fragments.</p>

<h4>Save vs. Save!</h4>

<p>While looking at validation failures, let&#8217;s highlight the difference between <code>.save</code> and <code>.save!</code>. Both methods run your validations, of course, but the consequences of a failure are different.</p>

<p>For example:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
ruby-1.9.2-p290 :001 &gt; p = Product.new<br>
 =&gt; #&lt;Product id: nil, title: nil, price: nil, description: nil, image_url: nil, created_at: nil, updated_at: nil, stock: 0&gt; <br>
ruby-1.9.2-p290 :002 &gt; p.save<br>
 =&gt; false <br>
ruby-1.9.2-p290 :003 &gt; p.save!<br>
ActiveRecord::RecordInvalid: Validation failed: Title can&#39;t be blank<br>
</p>

<p>A call to <code>save</code> will return <code>true</code> if the save succeeds and <code>false</code> if it fails. In your application code, you should react to this return value to determine next steps. For example:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
def create<br>
  @product = Product.new(params[:product])<br>
  if @product.save<br>
    redirect_to @product, :notice =&gt; &quot;Successfully created product.&quot;<br>
  else<br>
    render :action =&gt; &#39;new&#39;<br>
  end<br>
end<br>
</p>

<p>The <code>if</code>/<code>else</code> switches based on the success/failure of the <code>save</code>.</p>

<p>Alternatively, when we use <code>save!</code>&#8230;</p>

<p>1<br>
2<br>
3<br>
4<br>
ruby-1.9.2-p290 :001 &gt; p = Product.new<br>
 =&gt; #&lt;Product id: nil, title: nil, price: nil, description: nil, image_url: nil, created_at: nil, updated_at: nil, stock: 0&gt; <br>
ruby-1.9.2-p290 :002 &gt; p.save!<br>
ActiveRecord::RecordInvalid: Validation failed: Title can&#39;t be blank<br>
</p>

<p>When <code>.save!</code> succeeds it will also return <code>true</code>, but when it fails it will <em>raise an exception</em>. Well architected Ruby treats exceptions as extremely abnormal cases. For that reason, saving a model should only raise an exception when something <em>very strange</em> has happened, like the database has crashed. Users entering junky input is not unexpected, so we shouldn&#8217;t typically raise exceptions on a validation.</p>

<p>So when should you use <code>save!</code>? When you expect the validations to always pass. For instance, if your application is creating objects with no user input, it&#8217;d be very strange to have invalid data. Then use <code>save!</code> and skip the redirect. In such a scenario, redirecting someplace probably isn&#8217;t going to help, so your application should raise an exception.</p>

<h3>Displaying Errors</h3>

<p>Typically we react to <code>.save</code> in the controller and re-render the form if it returned <code>false</code>. Then in the UI we can display the errors for the user to correct.</p>

<h4>Back in Rails 2</h4>

<p>In the olden days, this was very easy. All you had to write in the helper was call <code>error_messages_for</code>:</p>

<p>1<br>
&lt;%= error_messages_for @product %&gt;<br>
</p>

<p>You&#8217;d get a box saying that there were errors and a bulleted list of the error messages. Assuming your form is using the <code>form_for</code> helper, the fields with the validation errors will automatically be wrapped with a <code>&lt;div class='field_with_error&gt;&lt;/div&gt;</code>. </p>

<p>But the markup was not customizable, so most production apps would end up rewriting it.</p>

<p>With Rails 3 the <code>error_messages_for</code> helper was removed.</p>

<h4>Writing a Helper Method</h4>

<p>But now we can write our own <code>error_messages_for</code>, imitate Rails 2, and leave the door open for easy customization at the design stage. Here&#8217;s an implementation from Ryan Bates of RailsCasts:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
10<br>
11<br>
12<br>
def error_messages_for(*objects)<br>
  options = objects.extract_options!<br>
  options[:header_message] ||= I18n.t(:&quot;activerecord.errors.header&quot;, :default =&gt; &quot;Invalid Fields&quot;)<br>
  options[:message] ||= I18n.t(:&quot;activerecord.errors.message&quot;, :default =&gt; &quot;Correct the following errors and try again.&quot;)<br>
  messages = objects.compact.map { |o| o.errors.full_messages }.flatten<br>
  unless messages.empty?<br>
    content_tag(:div, :class =&gt; &quot;error_messages&quot;) do<br>
      list_items = messages.map { |msg| content_tag(:li, msg) }<br>
      content_tag(:h2, options[:header_message]) + content_tag(:p, options[:message]) + content_tag(:ul, list_items.join.html_safe)<br>
    end<br>
  end<br>
end<br>
</p>

<p>It&#8217;s CSS-compatible with the original Rails 2 implementation and respects i18n message definitions.</p>

<h4>Custom Messages &amp; Internationalization</h4>

<p>All the validations support a :message parameter in the model where you can specify a custom message. But this is the wrong way to do it, and I hope that option is soon deprecated.<br>
</p>

<p>Error messages can be specified in our locale file. These files live in <code>config/locales/</code> and have names corresponding to the language code, like <code>en.yml</code> for English or <code>es.yml</code> for Spanish.</p>

<p>In that translation file you can override the default messages either globally for all uses of a validation or on a per-model basis. Check out the Rails source code for lots of details on implementation: <a href="https://github.com/rails/rails/blob/master/activerecord/lib/active_record/locale/en.yml">https://github.com/rails/rails/blob/master/activerecord/lib/active_record/locale/en.yml</a></p>

<p>Here&#8217;s an example based on <code>validates_presence_of :title</code> for a <code>Product</code>:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
en:<br>
  activerecord:<br>
    errors:<br>
      models:<br>
        product:<br>
          attributes:<br>
            title:<br>
              blank: &quot;Please enter a title.&quot;<br>
</p>

<h3>Client-Side Validation</h3>

<p>Web applications generally do a terrible job of coaching their users. You fill out a big form, click submit, then it&#8217;ll have an uninformative message at the top of the form like &quot;Form Had Errors&quot;.</p>

<p>To treat users with respect, we should run validations and give feedback as soon as possible. That means handling it on the client-side in JavaScript.</p>

<p>Should we re-implement all our model validations in JavaScript? No!</p>

<p>The Client-Side Validations gem (<a href="https://github.com/bcardarella/client_side_validations">https://github.com/bcardarella/client_side_validations</a>) will take care of everything for you. It will read your model validations, wrap them up into a JSON package, and send it to the client along with the form. Combined with a small JavaScript engine to process that JSON, you get a great user experience with very little work.</p>

<p>Check out the project page and readme for details on setup and usage.</p>

<h2>Database Validations</h2>

<p>For truly bullet-proof data integrity you&#8217;ll need to implement validations at the database level, too.</p>

<ul>
<li>The <code>foreigner</code> gem gives you the ability to add foreign key constraints to MySQL, PostgreSQL, and SQLite: <a href="https://github.com/matthuhiggins/foreigner">https://github.com/matthuhiggins/foreigner</a></li>
<li><code>validates_uniqueness_of</code> could, in theory, run into a race condition if there are two concurrent requests creating the same data. To protect against that, you can create a database index on the field and specify that it must be unique:</li>
</ul>

<pre lang="ruby"><code>  # in your migration...
  t.index(:title, :unique =&gt; true)
</code></pre>

<p>Then the database would reject a second submission with an existing title if it got past the Rails model validation</p>

<h2>Exercises</h2>

<p>[TODO: JSBlogger Setup]</p>

<ol>
<li>Write validations to check that an <code>Article</code> object must have both a title and a body.</li>
<li>Validate that a <code>Comment</code> has a body of less than 250 characters.</li>
<li>Validate that neither articles nor comments have your name in them.</li>
<li>Validate that a comment must have an associated article. Test it in your console and make sure it works as expected.</li>
<li>Build a module of <code>TextValidations</code> that can be shared by <code>Article</code> and <code>Comment</code>, then <code>include</code> it from both models.</li>
</ol>

<h2>References</h2>

<ul>
<li>Rails API for <code>validates_X_of</code> methods: <a href="http://api.rubyonrails.org/classes/ActiveModel/Validations/HelperMethods.html">http://api.rubyonrails.org/classes/ActiveModel/Validations/HelperMethods.html</a></li>
<li>Rails API for <code>validates</code> syntax: <a href="http://api.rubyonrails.org/classes/ActiveModel/Validations/ClassMethods.html#method-i-validates">http://api.rubyonrails.org/classes/ActiveModel/Validations/ClassMethods.html#method-i-validates</a></li>
<li>Tricks and techniques for Ruby exceptions: <a href="http://exceptionalruby.com/">http://exceptionalruby.com/</a></li>
<li>Client-Side Validations Gem: <a href="https://github.com/bcardarella/client_side_validations">https://github.com/bcardarella/client_side_validations</a></li>
<li>RailsCast on Client-Side Validations: <a href="http://railscasts.com/episodes/263-client-side-validations">http://railscasts.com/episodes/263-client-side-validations</a></li>
<li>ActiveRecord i18n Validation Messages: <a href="https://github.com/rails/rails/blob/master/activerecord/lib/active_record/locale/en.yml">https://github.com/rails/rails/blob/master/activerecord/lib/active_record/locale/en.yml</a></li>
<li>Rails Guide on i18n for Models: <a href="http://guides.rubyonrails.org/i18n.html#translations-for-active-record-models">http://guides.rubyonrails.org/i18n.html#translations-for-active-record-models</a></li>
<li>Rails migration methods including <code>index</code>: <a href="http://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/Table.html">http://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/Table.html</a></li>
</ul>

  
</article>

</div>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2011 - Jumpstart Lab -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
</body>
</html>
