
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Modules - Jumpstart Lab Curriculum</title>
  <meta name="author" content="Jumpstart Lab">

  
  <meta name="description" content="        Modules          One of the most powerful tools in a Rubyist&#8217;s toolbox is the module.NamespacingModules are used to namespace Ruby cl...">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://yoursite.com/models/modules.html">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection, print" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="http://s3.amazonaws.com/ender-js/jeesh.min.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Jumpstart Lab Curriculum" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

</head>

<body  >
  <header role="banner"><hgroup>
  <h1><a href="/">Jumpstart Lab Curriculum</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:yoursite.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
<ul class="main-navigation">
  <li><a href="/">Curriculum Index</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article role="article">
  
  <header>
    <h1 class="entry-title">Modules</h1>
    
  </header>
  
  <p>One of the most powerful tools in a Rubyist&#8217;s toolbox is the module.</p>

<h2>Namespacing</h2>

<p>Modules are used to namespace Ruby classes. For example, if we had this code:</p>

<p>1<br>
2<br>
3<br>
4<br>
module Sample<br>
  class Hello<br>
  end<br>
end<br>
</p>

<p>The class <code>Hello</code> would be wrapped in the <code>Sample</code> namespace. That means when we want to create an instance of <code>Hello</code> instead of:</p>

<p>1<br>
h = Hello.new<br>
</p>

<p>We would prefix it with the namespace and two colons:</p>

<p>1<br>
h = Sample::Hello.new<br>
</p>

<p>The primary purpose of namespacing classes is to avoid collision. If I write a library that has an <code>Asset</code> class, for instance, and you use my library in a program which already has an <code>Asset</code> class, the two class definitions will merge into one Frankenstein class, usually causing unexpected behavior.</p>

<p>If, instead, I wrap mine into a namespace <code>Packager</code>, then my <code>Packager::Asset</code> in the library and your <code>Asset</code> class can happily coexist.</p>

<h3>In Rails</h3>

<p>Modules can be used to namespace a group of related Rails models:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
10<br>
11<br>
12<br>
13<br>
14<br>
15<br>
# In packager/asset.rb<br>
module Packager<br>
  class Asset &lt; ActiveRecord::Base<br>
  end<br>
end<br>
<br>
# In packager/text.rb<br>
module Packager<br>
  class Text &lt; ActiveRecord::Base<br>
  end<br>
end<br>
<br>
# Used in a controller:<br>
asset = Packager::Asset.new<br>
text = Packager::Text.new<br>
</p>

<p>Typically the classes would be stored in a subfolder of models with the name of the namespace, so here <code>app/models/packager/*.rb</code></p>

<h2>Common Code</h2>

<p>The more common usage of modules in Rails is to share common code. These sometimes go by the nickname &quot;mix-ins&quot;, but that just means modules. </p>

<h3>Inheritance, Modules, and Rails</h3>

<p>Ruby implements a single inheritance model, so a given class can only inherit from one other class. Sometimes, though, it&#8217;d be great to inherit from two classes. Modules can cover that need.</p>


<p>In ActiveRecord, inheritance leads into Single Table Inheritance (STI). Most advanced Rails users agree that STI sounds like a good idea, then you end up ripping it out as the project matures. It just isn&#8217;t a strong design practice.</p>

<p>Instead, we mimic inheritance using modules and allow each model to have its own table.</p>


<h3>Instance Methods</h3>

<p>Let&#8217;s look at a scenario where two classes could share an instance method.</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
10<br>
11<br>
12<br>
13<br>
class Book &lt; ActiveRecord::Base<br>
  has_many :pages<br>
  def word_count<br>
    pages.inject(0){|count, page| count + page.word_count}<br>
  end<br>
end<br>
<br>
class Brochure &lt; ActiveRecord::Base<br>
  has_many :pages<br>
  def word_count<br>
    pages.inject(0){|count, page| count + page.word_count}<br>
  end<br>
end<br>
</p>

<p>The <code>word_count</code> method is obviously repeated verbatim. We could imagine that, in the future, we might want to modify the word count method so it doesn&#8217;t include &quot;a&quot;, &quot;and&quot;, &quot;or&quot;, etc. Or we want to pass in a word and have it tell us how many times that word appears in the document. </p>

<p>These changes will mean changing the same code in two places, and that a recipe for regression bugs. Instead, we extract the common code.</p>

<h4>Creating the Module</h4>

<p>First, we define the module. It can live in <code>/app/models</code> or another subfolder if you prefer:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
# app/models/text_content.rb<br>
module TextContent<br>
  def word_count<br>
    pages.inject(0){|count, page| count + page.word_count}<br>
  end<br>
end<br>
</p>

<p>Then make use of the module from the two classes:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
class Book &lt; ActiveRecord::Base<br>
  has_many :pages<br>
  include TextContent<br>
end<br>
<br>
class Brochure &lt; ActiveRecord::Base<br>
  has_many :pages<br>
  include TextContent<br>
end<br>
</p>

<p>The <code>include</code> method is basically like copying and pasting the module into that spot of the class. Any methods in the module are added as instance methods to the class. Nothing about the usage of <code>book.word_count</code> would change.</p>

<h3>Class Methods</h3>

<p>You can use modules to share class methods, too. Starting with similar models:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
10<br>
11<br>
12<br>
13<br>
class Book &lt; ActiveRecord::Base<br>
  #&#8230; other code<br>
  def self.title_search(fragment)<br>
    where(&quot;title LIKE ?&quot;, &quot;%#{fragment}%&quot;)<br>
  end<br>
end<br>
<br>
class Brochure &lt; ActiveRecord::Base<br>
  #&#8230; other code<br>
  def self.title_search(fragment)<br>
    where(&quot;title LIKE ?&quot;, &quot;%#{fragment}%&quot;)<br>
  end<br>
end<br>
</p>

<p>Extract the common code into a module:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
module TextSearch<br>
  def title_search(fragment)<br>
    where(&quot;title LIKE ?&quot;, &quot;%#{fragment}%&quot;)<br>
  end<br>
end<br>
</p>

<p>Note that we&#8217;ve removed the <code>self.</code> from the method definition. Then mix it into the original classes using <code>extend</code>:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
class Book &lt; ActiveRecord::Base<br>
  #&#8230; other code<br>
  extend TextSearch<br>
end<br>
<br>
class Brochure &lt; ActiveRecord::Base<br>
  #&#8230; other code<br>
  extend TextSearch<br>
end<br>
</p>

<p>Using <code>extend</code> adds the methods in the modules as <em>class methods</em> to the extending class. So our functionality, like <code>Brochure.title_search('World')</code> would be the same.</p>

<h3>Included</h3>

<p>Besides adding instance and class methods, sometimes you want some instructions to be run when your module is included. For instance, both of our sample classes have this line:</p>

<p>1<br>
has_many :pages<br>
</p>

<p>Though many developers don&#8217;t think about what this DSL is doing, it&#8217;s calling the class method <code>has_many</code>, defined in <code>ActiveRecord::Base</code>, and passing an argument of <code>:pages</code>.</p>

<p>If we put that line in a module and <code>include</code> the module we won&#8217;t get the desired output because it&#8217;ll be trying to define an instance method. If we use <code>extend</code> it still won&#8217;t work because we&#8217;d be defining a class methods rather than calling it.</p>

<p>What we need is the <code>.included</code> callback method, typically written like this:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
module HasPages<br>
  def self.included(base)<br>
    # Code to run when this module is included<br>
    # base is a reference to the including class<br>
  end<br>
end<br>
</p>

<p>The tricky part here is that the <code>included</code> method runs in the context of the module, not in the context of the containing class. So this will <em>not work</em>:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
module HasPages<br>
  def self.included(base)<br>
    base.has_many :pages<br>
  end<br>
end<br>
</p>

<p>It will fail because <code>has_many</code> is a private method on <code>ActiveRecord::Base</code>. Since the method is running outside the class it cannot access the private method.</p>

<p>But, in Ruby, everything is possible. If you want an object to run a private method you can use <code>.send</code> and pass the name of the method to run like this:</p>

<p>1<br>
object.send(:method)<br>
</p>

<p>That will run the <code>.method</code> inside the context of the class, so it works with public, private, or protected methods. You can pass parameters to the method by adding them to the send call:</p>

<p>1<br>
object.send(:method, param1, param2)<br>
</p>

<p>Getting back to our example, we want to call the method <code>has_many</code> and pass it the parameter <code>:pages</code>:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
module HasPages<br>
  def self.included(base)<br>
    base.send(:has_many, :pages)<br>
  end<br>
end<br>
</p>

<p>Now, when this module is included, the <code>has_many</code> class method will be successfully called with the parameter <code>:pages</code>. </p>

<h3>Bringing It All Together</h3>

<p>So how does this mimic inheritance? We can bring all three techniques together to share instance methods, class methods, and method calls or relationships.</p>

<p>Starting with this code:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
10<br>
11<br>
12<br>
13<br>
14<br>
15<br>
16<br>
17<br>
18<br>
19<br>
class Book &lt; ActiveRecord::Base<br>
  has_many :pages<br>
  def word_count<br>
    pages.inject(0){|count, page| count + page.word_count}<br>
  end<br>
  def self.title_search(fragment)<br>
    where(&quot;title LIKE ?&quot;, &quot;%#{fragment}%&quot;)<br>
  end<br>
end<br>
<br>
class Brochure &lt; ActiveRecord::Base<br>
  has_many :pages<br>
  def word_count<br>
    pages.inject(0){|count, page| count + page.word_count}<br>
  end<br>
  def self.title_search(fragment)<br>
    where(&quot;title LIKE ?&quot;, &quot;%#{fragment}%&quot;)<br>
  end<br>
end<br>
</p>

<p>We can write a module like this:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
10<br>
11<br>
12<br>
13<br>
module TextContent<br>
  def word_count<br>
    pages.inject(0){|count, page| count + page.word_count}<br>
  end<br>
<br>
  def self.title_search(fragment)<br>
    where(&quot;title LIKE ?&quot;, &quot;%#{fragment}%&quot;)<br>
  end<br>
<br>
  def self.included(base)<br>
    base.send(:has_many, :pages)<br>
  end<br>
end<br>
</p>

<p>Then our models become:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
class Book &lt; ActiveRecord::Base<br>
  include TextContent<br>
end<br>
<br>
class Brochure &lt; ActiveRecord::Base<br>
  include TextContent<br>
end<br>
</p>

<h3>Style Points</h3>

<p>Inside the module there is a common pattern for organizing methods to group them as instance or class methods. It looks like this:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
10<br>
11<br>
12<br>
13<br>
14<br>
module ModuleName<br>
  module InstanceMethods<br>
    def my_instance_method<br>
    end<br>
  end<br>
  module ClassMethods<br>
    def my_class_method<br>
    end<br>
  end<br>
  def self.included(base)<br>
    base.send(:include, InstanceMethods)<br>
    base.send(:extend, ClassMethods)<br>
  end<br>
end<br>
</p>

<p>Now we trigger <code>include</code> on the including class to add the <code>InstanceMethods</code> nested module and use <code>extend</code> to add the <code>ClassMethods</code> module as class methods. In this usage, there&#8217;s nothing special about the names <code>InstanceMethods</code> and <code>ClassMethods</code>, they&#8217;re just conventional.</p>

<p>We&#8217;d rewrite our module like this to follow the pattern:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
10<br>
11<br>
12<br>
13<br>
14<br>
15<br>
16<br>
17<br>
18<br>
19<br>
module TextContent<br>
  module InstanceMethods<br>
    def word_count<br>
      pages.inject(0){|count, page| count + page.word_count}<br>
    end<br>
  end<br>
<br>
  module ClassMethods<br>
    def title_search(fragment)<br>
      where(&quot;title LIKE ?&quot;, &quot;%#{fragment}%&quot;)<br>
    end<br>
  end<br>
<br>
  def self.included(base)<br>
    base.send(:include, InstanceMethods)<br>
    base.send(:extend, ClassMethods)<br>
    base.send(:has_many, :pages)<br>
  end<br>
end<br>
</p>

<p>The usage of the module would not change:</p>

<p>1<br>
2<br>
3<br>
class Book &lt; ActiveRecord::Base<br>
  include TextContent<br>
end<br>
</p>

<h2><code>ActiveSupport::Concern</code></h2>

<p>Rails 3 introduced a module named <code>ActiveSupport::Concern</code> which has the goal of simplifying the syntax of our modules.</p>

<p>To demonstrate it&#8217;s usage, let&#8217;s refactor the <code>TextContent</code> module above.</p>

<h3>Setup</h3>

<p>First, just inside the module opening, we <code>extend</code> the helper:</p>

<p>1<br>
2<br>
3<br>
4<br>
module TextContent<br>
  extend ActiveSupport::Concern<br>
  #&#8230;<br>
end<br>
</p>

<p>Now <code>ActiveSupport::Concern</code> is activated.</p>

<h3><code>included</code></h3>

<p>In the original, we define the method callback <code>self.included(base)</code>. With <code>ActiveSupport::Concern</code>, instead we call a class method on the module itself named <code>included</code>:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
module TextContent<br>
  extend ActiveSupport::Concern<br>
  included do<br>
    include InstanceMethods<br>
    extend ClassMethods<br>
    has_many :pages<br>
  end<br>
  #&#8230;<br>
end<br>
</p>

<h3>Interior Modules</h3>

<p>The original <code>TextContent</code> follows a very common pattern of using a nested module named <code>InstanceMethods</code> to contain the instance methods and <code>ClassMethods</code> to hold the class methods.</p>

<p><code>ActiveSupport::Concern</code> is built to support this structure. Specifically, we can omit the calls to <code>extend</code> and <code>include</code> within <code>included</code> &#8211; they&#8217;ll be triggered automatically:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
module TextContent<br>
  extend ActiveSupport::Concern<br>
  included do<br>
    has_many :pages<br>
  end<br>
  #&#8230;<br>
end<br>
</p>

<h3>Completed Refactoring</h3>

<p>So, in the end, we have:</p>

<p>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
10<br>
11<br>
12<br>
13<br>
14<br>
15<br>
16<br>
17<br>
18<br>
19<br>
module TextContent<br>
  extend ActiveSupport::Concern<br>
<br>
  module InstanceMethods<br>
    def word_count<br>
      pages.inject(0){|count, page| count + page.word_count}<br>
    end<br>
  end<br>
<br>
  module ClassMethods<br>
    def title_search(fragment)<br>
      where(&quot;title LIKE ?&quot;, &quot;%#{fragment}%&quot;)<br>
    end<br>
  end<br>
<br>
  included do<br>
    has_many :pages<br>
  end<br>
end<br>
</p>

<p><code>ActiveSupport::Concern</code> allowed us to save a few lines of &quot;boilerplate&quot; code in the module.</p>

<h2>Exercises</h2>

<p>[TODO: Setup JSBlogger]</p>

<ol>
<li>Define the <code>TextContent</code> module as described above.</li>
<li>Include the module into both <code>Comment</code> and <code>Article</code> models.</li>
<li>Display the <code>word_count</code> in the <code>articles#show</code> view template.</li>
<li>Define a second module named <code>Commentable</code> that, for starters, just causes the including class to run <code>has_many :comments</code>. Remove the <code>has_many</code> from <code>Article</code> and, instead, include the module.</li>
<li>Define an instance method in the <code>Commentable</code> module named <code>has_comments?</code> which returns true or false based on the existence of comments. In the <code>articles#show</code> view, use that method to show or hide the comments display based on their existence.</li>
</ol>

  
    <footer>
      
      
        <div class="sharing">
  
  
</div>

      
    </footer>
  
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
  </ul>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2011 - Jumpstart Lab -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  


  

  

  

</body>
</html>
