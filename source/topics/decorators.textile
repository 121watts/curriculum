---
layout: default
title: Experimenting with Decorators
---

Let's play around with the concept of decorators and check out some of the features offered by the Draper gem.

h3. Setup

First we need a sample project. I've setup a version of our JSMerchant project, a simple online store, that we can experiment with. To clone the sample project:

<pre class="console">
  git clone git://github.com/JumpstartLab/jsmerchant_online.git
</pre>

Then change into the project directory.

h3. Install Draper

Next, open the @Gemfile@ and add a dependency on @'draper'@ like this:

<pre class="brush:ruby">
  gem 'draper'
</pre>

Run @bundle@, then start up your server.

h3. Generate a Decorator

We'll create a decorator to wrap the @Product@ model. Draper gives you a handy generator:

<pre class="console">
  rails generate draper:model Product
</pre>

It will create the folder @app/decorators/@ and the file @app/decorators/product_decorator.rb@. Open the file and you'll find the frame of a @ProductDecorator@ class.

*Restart* your server so the new folder is added to the load path.

h3. First Usage

Without changing the decorator, let's see the simplest usage. Open the @products_controller@ and look at the @show@ action. It currently has:

<pre class="brush:ruby">
  def show
    @product = Product.find(params[:id])
  end  
</pre>

To make use of the decorator, call the @.new@ method and pass in the product from the database:

<pre class="brush:ruby">
  def show
    source = Product.find(params[:id])
    @product = ProductDecorator.new(source)
  end
</pre>

Then go and view the show page for a single product by clicking on its name on the index.

h4. Polymorphic Path Bug -- FIXED??

*Update*: I think I've got this nailed, but leaving the note here for now, just in case.

You will likely hit a bug here: @undefined method 'name' for nil@. The show template is relying on Rails' polymorphic path which jumps through some complex hoops to figure out the proper path name. It's fixable, but the solution isn't quite right yet.

The fix is to just use a normal path. Open the @show.html.erb@ template and change the destroy link like this:

<pre class="brush:ruby">
  <%= link_to "Destroy", product_path(@product), :confirm => 'Are you sure?', :method => :delete %>
</pre>

Now your decorator is in action -- doing nothing of interest.

h3. Adding Methods

Now let's add some actual functionality to our decorator.

h4. Product Price

Currently the show page just displays the raw @price@ attribute. There is a helper named @print_price@ in @ApplicationHelper@ that wraps the price in a currency format.

The challenge is that we have to remember to use that helper whenever we output the price. What a pain! Instead, let's override the @price@ method in our decorator:

<pre class="brush:ruby">
  def price
    helpers.number_to_currency(source.price)
  end
</pre>

This uses two methods inherited from the @Draper::Base@. First we have a method @helpers@ that is a proxy to ActionView's built-in helpers. That way we don't have to include *all* of the helpers directly in our decorator.

The second is @source@ which stores the original wrapped object. We can use the accessor to reach methods not available in the decorator, such as ones we override or explicitly deny.

h4. Product Stock

Currently the show page uses the @print_stock@ helper:

<pre class="brush:ruby">
  <%= print_stock @product.stock %>
</pre>

Find that method in @ProductsHelper@ and try rewriting it into your decorator. The @content_tag@ helper is available as a normal method in the decorator class.

h3. Using Denies

When we define an interface we want to be able to exclude or include specific accessors. Let's try using the @denies@ method.

Denies is modeled after @attr_protected@ in Rails. If you don't use the method, everything is permitted. If you do use the method, then all calls are permitted except to those listed in the denies call.

For instance, say we wanted to block usage of @updated_at@. First, add it as a display item in the show view:

<pre class="brush:ruby">
  <p>
    Last Updated: <%= @product.updated_at %>
  </p>
</pre>

Refresh your browser and the timestamp should show up. Now let's try denying access to that method. Inside your @ProductDecorator@ class, add this:

<pre class="brush:ruby">
  class ProductDecorator < Draper::Base
    denies :updated_at
    #...
</pre>

Refresh your page and it should raise an exception, the method @updated_at@ is not defined.

h3. Using Allows

When writing models, @attr_protected@ is not frequently used. More often we want to define a whitelist using @attr_accessible@. The same is true with decorator models. It's more common to specify which methods are made available.

h4. Combining Allows and Denies

First, try adding this line right under the @denies@:

<pre class="brush:ruby">
  allows :title
</pre>

Refresh your page and you should see an exception. You can't use both @allows@ and @denies@ in the same decorator because it leaves ambiguity about the unlisted methods. Remove the @denies@ line and try again.

h4. Allowing More Methods

So far you're only allowing @:title@, so you'll get exceptions as the other accessors try to pull out data. Add the appropriate methods to @allows@, separated by commas. Make sure you include @to_param@ so your links will work properly.

Note that you don't need to @allow@ methods defined in the decorator, they're allowed by default.

h4. Now, Play!

Here are some other things you can try:

* Define a @to_xml@ or @to_json@ in the decorator and use @respond_with@ to serve them up
* Try calling @ProductDecorator.decorate(sources)@ to create an array of decorated objects from an array of source objects, then use experiment with the @index@
* Try defining a format attribute on your decorator (so it'd hold a value like @:xml@ or @:json@), set it when creating the decorator instance, then in your methods react to that attribute to output formatted data. (_ASIDE:_ Is this a good idea? It'd probably be better to define a parent decorator like @ProductDecorator@, then create subclasses @ProductDecoratorXML@ and @ProductDecoratorJSON@.)

h3. Where We Go from Here

The decorator pattern is ready to start replacing your helpers and defining an interface between view template and data. What's next?

The next challenge is to provide access to traditional user-defined helpers from within the decorator. For instance, to do proper data shaping based on authorization, we would want to call @current_user@ from within the decorator. ActiveView provides a way to proxy the built in helpers, but there isn't one for user defined helpers. There's a tricky hack to do it that we'll likely implement soon.

Respected friend Xavier Shay posts his solution here: https://gist.github.com/1077274

From there, it's time for some real-world usage. I'd love your help testing this out with experimental code. Please don't use it in a production system until it hits 1.0!